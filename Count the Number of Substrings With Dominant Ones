class Solution {
public:
    int numberOfSubstrings(string s) {
        int n = s.length();

        vector<int> cumCountOne(n, 0);
        cumCountOne[0] = (s[0] == '1') ? 1 : 0;
        // [i .. j] -> count 1 = cumCountOne[j] - cumCountOne[i - 1] 
        for(int i = 1; i < n; i++) {
            cumCountOne[i] = cumCountOne[i - 1] + ((s[i] == '1') ? 1 : 0);
        }

        int result = 0;
        for(int i = 0; i < n; i++) {
            for(int j = i; j < n; j++) {

                int oneCount = cumCountOne[j] - ((i >= 1) ? cumCountOne[i - 1] : 0);
                int zeroCount = (j - i + 1) - oneCount;

                if((zeroCount * zeroCount) > oneCount) {
                    // skip j to avoid waste indices
                    int wasteIndices = (zeroCount * zeroCount) - oneCount;
                    j += wasteIndices - 1; // j st right place but j++ in for loop so -1
                }
                else if((zeroCount * zeroCount) == oneCount) {
                    result += 1;
                }
                else { // (zeroCount * zeroCount) < oneCount
                    // [i...j] is a valid dominant substring
                    result += 1;

                    // try to see how much j can shift to right until substring remain dominant
                    int k = sqrt(oneCount) - zeroCount;
                    int next_j = j + k;

                    if(next_j >= n) { // out of bound .. all valid indicies
                        result += (n - j - 1);
                        break; // earlt break
                    }
                    else {
                        result += k;
                    }

                    j = next_j;
                }
            }
        }

        return result;
    }
};

// TC : O(n * n) : Worst case

// O(n) -> bahar wala 
// j -> i 
// j - i - 1 = L
// L^2 ---> ~n
// L = sqrt(n)
// TC : O(n * sqrt(n)) : Best case
