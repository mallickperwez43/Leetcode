class Solution {
public:

    bool check(long long mid, vector<long long>& diff, int r, int k, int n) {
        vector<long long> tempDiff = diff;

        long long cumSum = 0; // it will give power of a city at any point of time

        for(int i = 0; i < n; i++) {
            cumSum += tempDiff[i];

            if(cumSum < mid) {
                long long need = mid - cumSum;
                if(need > k) {
                    return false;
                }

                k -= need;
                cumSum += need; // greedily I had chosen to add station on the city which can cover more range((i + r)th city)

                // i.......x........i+2*r
                if(i + 2 * r + 1 < n) {
                    tempDiff[i + 2 * r + 1] -= need; // applying difference array technique;
                }
            }
        }

        return true;
    }
     
    long long maxPower(vector<int>& stations, int r, int k) {
        int n = stations.size();

        vector<long long> diff(n, 0);

        for(int i = 0; i < n; i++) {
            diff[max(0, i - r)] += stations[i];

            if(i + r + 1 < n) {
                diff[i + r + 1] -= stations[i];
            }
        }

        long long low  = *min_element(stations.begin(), stations.end()); 
        long long high = accumulate(stations.begin(), stations.end(), 0LL) + k;

        long long result = 0;

        while(low <= high) { // O(log(high - low))
            long long mid = low + (high - low) / 2;

            if(check(mid, diff, r, k, n)) { // O(n)
                result = mid;
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        } 

        return result;
    }
};

// TC : O(n * log(high - low))
// SC : O(n)
