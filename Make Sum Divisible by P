class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
        int n = nums.size();
        int SUM = 0;
        
        // (a + b) % p = (a % p + b % p) % p
        for(int &num : nums){
            SUM = (SUM + num) % p;
        }

        int target = SUM % p;

        if(target == 0) {
            return 0;
        }

        unordered_map<int, int> mp; // prev (sum % p) -> index
        int cur = 0;
        mp[0] = -1;
        
        int result = n;
        for(int j = 0; j < n; j++){
            cur = (cur + nums[j]) % p;

            int remian = (cur - target + p) % p; // handling negative modulo
            if(mp.find(remian) != mp.end()){
                result = min(result, j - mp[remian]);
            } 

            mp[cur] = j;
        }

        return result == n ? -1 : result;;
    }
};

// TC : O(n)
// SC : O(n)
