// RECURSION -> TLE

class Solution {
public:
    
    int M = 1e9 + 7;

    int solve(int n, int num, int x) {
        // Base case
        if(n == 0) 
            return 1; // 1 path found

        if(n < 0) 
            return 0;
        
        int curPowerValue = pow(num, x);

        if(curPowerValue > n) 
            return 0;

        int take = solve(n - curPowerValue, num + 1, x);
        int skip = solve(n, num + 1, x);

        return (take + skip) % M;
    }

    int numberOfWays(int n, int x) {
        return solve(n, 1, x);
    }
};


// RECURSION + MEMOIZATION

class Solution {
public:
    
    int M = 1e9 + 7;

    int solve(int n, int num, int x, vector<vector<int>>& dp) {
        // Base case
        if(n == 0) 
            return 1; // 1 path found

        if(n < 0) 
            return 0;
        
        int curPowerValue = pow(num, x);

        if(curPowerValue > n) 
            return 0;
        
        if(dp[n][num] != -1)
            return dp[n][num];

        int take = solve(n - curPowerValue, num + 1, x, dp);
        int skip = solve(n, num + 1, x, dp);

        return dp[n][num] = (take + skip) % M;
    }

    int numberOfWays(int n, int x) {
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
        return solve(n, 1, x, dp);
    }
};
