// Brute Force

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int count = 0;

        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] < 0) {
                    count++;
                }
            }
        }

        return count;
    }
};

// TC : O(m * n)
// SC : O(1)


// Better (Binary Search)

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int count = 0;

        for(auto& row : grid) {
            
            int idx = upper_bound(row.begin(), row.end(), 0, greater<int>()) - row.begin();

            count += (n - idx);
        }

        return count;
    }
};

// TC : O(m * logn)
// SC : O(1)


// Optimal (Binary Search -> Reducing search space)

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int row = m - 1;
        int col = 0;
        int count = 0;

        while(row >= 0 && col < n) {
            if(grid[row][col] < 0) {
                count += (n - col);
                row--;
            }
            else col++;
        }

        return count;
    }
};

// TC : O(m + n)
// SC : O(1)
