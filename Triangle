// Approach 1 : Recursion + Memoization 

class Solution {
public:
    int n;

    int solve(vector<vector<int>>& triangle, int row, int col, vector<vector<int>>& dp) {
        // base case
        if(row == n - 1) {
            return triangle[row][col];
        }

        if(dp[row][col] != INT_MAX) {
            return dp[row][col];
        }

        int minSum = triangle[row][col];

        int justDown = solve(triangle, row + 1, col, dp);
        int diaDown  = solve(triangle, row + 1, col + 1, dp);

        minSum += min(justDown, diaDown);

        return dp[row][col] = minSum;
    }

    int minimumTotal(vector<vector<int>>& triangle) {
        n = triangle.size();

        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));

        return solve(triangle, 0, 0, dp);    
    }
};


// Approach 2 : Bottom Up

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<vector<int>> dp = triangle;
        // dp[row][col] = min path sum from [row][col] to bottom of the triangle

        for(int row = n - 2; row >= 0; row--) {
            for(int col = 0; col <= row; col++) {
                dp[row][col] = dp[row][col] + min(dp[row + 1][col], dp[row + 1][col + 1]);
            }
        }

        return dp[0][0]; // min path sum from [0][0] to bottom   
    }
};

// TC : O(n ^ 2)
// SC : O(n ^ 2)


// Approach 3 : Optimised Bottom Up (1D)

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<int> dp = triangle[n - 1]; // 1D -> row + 1 
        // dp[col] = min path sum from [col] to bottom of the triangle

        for(int row = n - 2; row >= 0; row--) {
            for(int col = 0; col <= row; col++) {
                dp[col] = triangle[row][col] + min(dp[col], dp[col + 1]);
            }
        }

        return dp[0]; // min path sum from [0] to bottom   
    }
};

// TC : O(n ^ 2)
// SC : O(n)


