// Approach 1 : Recursion + Memoization 

class Solution {
public:
    int n;

    int solve(vector<vector<int>>& triangle, int row, int col, vector<vector<int>>& dp) {
        // base case
        if(row == n - 1) {
            return triangle[row][col];
        }

        if(dp[row][col] != INT_MAX) {
            return dp[row][col];
        }

        int minSum = triangle[row][col];

        int justDown = solve(triangle, row + 1, col, dp);
        int diaDown  = solve(triangle, row + 1, col + 1, dp);

        minSum += min(justDown, diaDown);

        return dp[row][col] = minSum;
    }

    int minimumTotal(vector<vector<int>>& triangle) {
        n = triangle.size();

        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));

        return solve(triangle, 0, 0, dp);    
    }
};


// Approach 2 : Bottom Up

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<vector<int>> dp = triangle;
        // dp[row][col] = min path sum from [row][col] to bottom of the triangle

        for(int row = n - 2; row >= 0; row--) {
            for(int col = 0; col <= row; col++) {
                dp[row][col] = dp[row][col] + min(dp[row + 1][col], dp[row + 1][col + 1]);
            }
        }

        return dp[0][0]; // min path sum from [0][0] to bottom   
    }
};

// TC : O(n ^ 2)
// SC : O(n ^ 2)


// Approach 3 : Optimised Bottom Up (1D)

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<int> dp = triangle[n - 1]; // 1D -> row + 1 
        // dp[col] = min path sum from [col] to bottom of the triangle

        for(int row = n - 2; row >= 0; row--) {
            for(int col = 0; col <= row; col++) {
                dp[col] = triangle[row][col] + min(dp[col], dp[col + 1]);
            }
        }

        return dp[0]; // min path sum from [0] to bottom   
    }
};

// TC : O(n ^ 2)
// SC : O(n)



// Approach 4 : Bottom Up (Top Down)

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        for(int row = 1; row < n; row++) {
            for(int col = 0; col <= row; col++) {
                int prev_row_up   = triangle[row - 1][min(col, (int)triangle[row - 1].size() - 1)];
                int prev_row_left = triangle[row - 1][max(col - 1, 0)];

                triangle[row][col] += min(prev_row_up, prev_row_left);
            }
        }

        return *min_element(triangle[n - 1].begin(), triangle[n - 1].end()); 
    }
};

// TC : O(n ^ 2)
// SC : O(1) // modified input itself
