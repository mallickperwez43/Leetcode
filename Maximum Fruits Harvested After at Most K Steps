class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n = fruits.size();

        vector<int> prefixSum(n); // storing the prefix sum of fruits
        vector<int> positions(n); // storing the postions of fruits (sorted already)

        for(int i = 0; i < n; i++) {
            positions[i] = fruits[i][0];

            prefixSum[i] = fruits[i][1] + (i > 0 ? prefixSum[i - 1] : 0);
        }

        int maxFruits = 0;

        for(int d = 0; d <= k / 2; d++) {

            // case 1 -> moved d steps to left 
            int remainingSteps = k - 2 * d;
            int i = startPos - d;
            int j = startPos + remainingSteps;
             
            int left  = lower_bound(positions.begin(), positions.end(), i) - positions.begin();
            int right = upper_bound(positions.begin(), positions.end(), j) - positions.begin() - 1;
            
            if(left <= right) { 
                int total = prefixSum[right] - (left > 0 ? prefixSum[left - 1] : 0);
                maxFruits = max(maxFruits, total);
            }

            // case 2 -> moved d to the right
            remainingSteps = k - 2 * d;
            i = startPos - remainingSteps; 
            j = startPos + d;

            left  = lower_bound(positions.begin(), positions.end(), i) - positions.begin();
            right = upper_bound(positions.begin(), positions.end(), j) - positions.begin() - 1;

            if(left <= right) { 
                int total = prefixSum[right] - (left > 0 ? prefixSum[left - 1] : 0);
                maxFruits = max(maxFruits, total);
            }
        }

        return maxFruits;
    }
};


// Custom Functions

class Solution {
public:
    int customLowerBound(vector<int>& pos, int target) {
        int low  = 0;
        int high = pos.size() - 1;
        int result = pos.size();

        while(low <= high) {
            int mid = low + (high - low) / 2;
            
            if(pos[mid] >= target) {
                result = mid;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }

        return result;
    }

    int customUpperBound(vector<int>& pos, int target) {
        int low  = 0;
        int high = pos.size() - 1;
        int result = pos.size();

        while(low <= high) {
            int mid = low + (high - low) / 2;
            
            if(pos[mid] > target) {
                result = mid;
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }

        return result;
    }

    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n = fruits.size();

        vector<int> prefixSum(n); // storing the prefix sum of fruits
        vector<int> positions(n); // storing the postions of fruits (sorted already)

        for(int i = 0; i < n; i++) {
            positions[i] = fruits[i][0];

            prefixSum[i] = fruits[i][1] + (i > 0 ? prefixSum[i - 1] : 0);
        }

        int maxFruits = 0;

        for(int d = 0; d <= k / 2; d++) {

            // case 1 -> moved d steps to left 
            int remainingSteps = k - 2 * d;
            int i = startPos - d;
            int j = startPos + remainingSteps;
             
            int left  = customLowerBound(positions, i);
            int right = customUpperBound(positions, j) - 1;
            
            if(left <= right) { 
                int total = prefixSum[right] - (left > 0 ? prefixSum[left - 1] : 0);
                maxFruits = max(maxFruits, total);
            }

            // case 2 -> moved d to the right
            remainingSteps = k - 2 * d;
            i = startPos - remainingSteps; 
            j = startPos + d;

            left  = customLowerBound(positions, i);
            right = customUpperBound(positions, j) - 1;

            if(left <= right) { 
                int total = prefixSum[right] - (left > 0 ? prefixSum[left - 1] : 0);
                maxFruits = max(maxFruits, total);
            }
        }

        return maxFruits;
    }
};
