// Using map

class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();

        map<int, vector<int>> mp; // {i + j -> {elements}}

        vector<int> result;

        // fill the map using [i + j]
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                mp[i + j].push_back(mat[i][j]);
            }
        }
        
        bool flip = true;
        for(auto& it : mp) {
            if(flip) {
                // it.second ko reverse
                reverse(it.second.begin(), it.second.end());
            }

            for(int& num : it.second) {
                result.push_back(num);
            }

            flip = !flip;
        }

        return result;
    }
};


// Using row + col to solve in O(1) space
// [i + j] -> even, move up right (i--, j++)
// [i + j] -> odd, move up down left (i++, j--)

class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        if(mat.empty() || mat[0].empty()) 
            return {};
        
        int m = mat.size();
        int n = mat[0].size();
        
        vector<int> result(m * n);

        int total = m * n;
        int curr = 0;
        int row = 0;
        int col = 0;
         
        while(row < m && col < n && curr < total) {
            result[curr++] = mat[row][col];

            if((row + col) & 1) {
                if(row == m - 1) col++;
                else if (col == 0) row++;
                else {
                    row++;
                    col--;
                }
            }
            else {
                if(col == n - 1) row++;
                else if(row == 0) col++;
                else {
                    row--;
                    col++;
                }
            }
        }

        return result;
    }
};
