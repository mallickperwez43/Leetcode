class Solution {
public:
    
    void pushNextLevelWords(string curr, queue<pair<string, int>>& q, unordered_map<string, bool>& vis,
            unordered_set<string>& wordSet, int level) {
        int n = curr.length();

        for(int i = 0; i < n; i++) { // iterate on every character of the curr word
            char originalChar = curr[i];

            // try placing every char in this ith char place and see if there is a path
            for(char ch = 'a'; ch <= 'z'; ch++) {
                curr[i] = ch;
                if(wordSet.count(curr) && !vis[curr]) {
                    q.push(make_pair(curr, level));
                    vis[curr] = true;
                }
            }

            curr[i] = originalChar; // place it back
        }
    }

    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        if(wordList.size() == 0)
            return 0;
        
        // placing in the set to get the word in O(1) time
        unordered_set<string> wordSet(wordList.begin(), wordList.end());

        // edge case -> endWord is not in the list
        if(!wordSet.count(endWord))
            return 0;
        
        // visited map
        unordered_map<string, bool> visited;
        for(string& word : wordList) {
            visited[word] = false;
        }

        // smallest transformation -> shortest path to reach from startWord to targetWord
        queue<pair<string, int>> q;
        // {word, level}

        q.push(make_pair(beginWord, 1));
        visited[beginWord] = true;

        while(!q.empty()) {
            auto [curr, level] = q.front();
            q.pop();

            if(curr == endWord)
                return level;
            
            pushNextLevelWords(curr, q, visited, wordSet, level + 1);
        }

        return 0; // never found the endWord
    }
};
