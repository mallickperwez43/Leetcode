// Brute Force

class Solution {
public:
    
    bool isIncreasing(vector<int>& nums, int start, int len) {

        for(int i = start + 1; i < len; i++) {
            if(nums[i] <= nums[i - 1]) { // not increasing
                return false;
            }
        }

        return true;
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        for(int start = 0; start + 2 * k <= n; start++) {
            bool first  = isIncreasing(nums, start, start + k);
            bool second = isIncreasing(nums, start + k, start + 2 * k);

            if(first && second) {
                return true;
            }
        }

        return false;
    }
};


// Optimal

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        int currRun = 1; // nums[0];
        int prevRun = 0;

        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                currRun++;
            }
            else { // increasing order has broken
                prevRun = currRun;
                currRun = 1;
            }
            
            if(currRun  >= 2 * k) { // currRun can be taken as two increasing subarrays of len k
                return true;
            }

            if(min(currRun, prevRun) >= k) {
                return true;
            }
        } 

        return false;
    }
};

// TC: O(n)
// SC: O(1)
