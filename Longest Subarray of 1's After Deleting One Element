// BRUTE FORCE -> TLE

class Solution {
public:
    int n;

    int findMax(vector<int>& nums, int skip_idx) {
        int curLength = 0;
        int maxLength = 0;

        for(int i = 0; i < n; i++) {
            if(i == skip_idx) 
                continue;
            
            if(nums[i] == 1) {
                curLength++;
                maxLength = max(maxLength, curLength);
            }
            else 
                curLength = 0;
        }

        return maxLength;
    }

    int longestSubarray(vector<int>& nums) {
        n = nums.size();

        int result = 0;
        int countZero = 0;

        for(int i = 0; i < n; i++) {

            if(nums[i] == 0) {
                countZero++;
                result = max(result, findMax(nums, i));
            }

        }    
        
        if(countZero == 0)
            return n - 1;

        return result;
    }
};


// BETTER -> SLIDING WINDOW

class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int zeroCount = 0;
        int maxLength = 0;
        
        int i = 0;
        int j = 0;

        while(j < n) {

            if(nums[j] == 0)
                zeroCount++;
            
            while(zeroCount > 1 && i < j) {
                if(nums[i] == 0)
                    zeroCount--;
                i++;
            }

            maxLength = max(maxLength, j - i);

            j++;
        }

        
        
        return maxLength;
    }
};


// OPTIMAL -> SLIDING WINDOW(jumping i)

class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        
        int i = 0;
        int j = 0;

        int last_zero_idx = -1;

        int result = 0;

        while(j < n) {

            if(nums[j] == 0) {
                i = last_zero_idx + 1; // jump to next (greedily moving window)
                last_zero_idx = j;
            }

            result = max(result, j - i);

            j++;
        }
        
        return result;
    }
};
