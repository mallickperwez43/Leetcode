// way 1

class Solution {
public:
    
    int onedArrayCount(vector<int>& vec) {
        int consecutiveOneCnt = 0;
        int subarrayCount = 0;

        for(int &val : vec) {
            if(val == 0)
                consecutiveOneCnt = 0;
            else 
                consecutiveOneCnt++;
            
            subarrayCount += consecutiveOneCnt;
        }

        return subarrayCount;
    }

    int numSubmat(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size(); 

        int result = 0;

        for(int startRow = 0; startRow < m; startRow++) { // starting row

            vector<int> vec(n, 1);

            for(int endRow = startRow; endRow < m; endRow++) { // ending row
                
                for(int col = 0; col < n; col++) { // for each col
                    vec[col] &= mat[endRow][col];
                }

                result += onedArrayCount(vec);
            }
        }

        return result;
    }
};

// TC : O(m * m * n)
// SC : O(n)


// way 2

class Solution {
public:
    
    int numSubmat(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size(); 

        int result = 0;

        vector<int> heights(n, 0); // Like histoogram
    
        for(int i = 0; i < m; i++) {

            // update histograms heights   
            for(int j = 0; j < n; j++) {
                mat[i][j] ? heights[j] += 1 : heights[j] = 0;
            }
            
            // count submatrices using histogram    
            for (int j = 0; j < n; j++) {
                int minHeight = heights[j]; // the range until its all ones
                for(int k = j; k >= 0 && minHeight > 0; k--) {
                    minHeight = min(minHeight, heights[k]);
                    result += minHeight;
                }
            }
        }
        
        return result;
    }
};

// TC : O(m * n * n)
// SC : O(n)
