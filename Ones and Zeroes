// Recursion + Memoization

class Solution {
public:
    
    int solve(vector<pair<int, int>>& count, int m, int n, int idx, vector<vector<vector<int>>>& dp) {
        if(idx >= count.size() || (m == 0 && n == 0)) {
            return 0;
        }
        
        if(dp[m][n][idx] != -1) {
            return dp[m][n][idx];
        }

        int take = 0;
        if(count[idx].first <= m && count[idx].second <= n) {
            take = 1 + solve(count, m - count[idx].first, n - count[idx].second, idx + 1, dp);
        }

        int no_take = solve(count, m, n, idx + 1, dp);

        return dp[m][n][idx] = max(take, no_take);
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        int N = strs.size();

        vector<pair<int, int>> count(N);
        for(int i = 0; i < N; i++) {
            int countZeros = 0;
            int countOnes  = 0;

            for(char& ch : strs[i]) {
                if(ch == '0') {
                    countZeros++;
                }
                else {
                    countOnes++;
                }
            }

            count[i] = make_pair(countZeros, countOnes); 
        }
        
        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(N + 1, -1)));

        return solve(count, m, n, 0, dp);
    }
};
