// Approach 1 : Greedy

class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        int sum = 0;
        // contains numbers which gives remainder 1 when divided by 3
        vector<int> remain1;
        
        // contains numbers which gives remainder 2 when divided by 3
        vector<int> remain2;
        
        for(int& num : nums) {
            sum += num;

            if(num % 3 == 1) {
                remain1.push_back(num);
            }
            else if(num % 3 == 2) {
                remain2.push_back(num);
            }
        }

        if(sum % 3 == 0) {
            return sum;
        }

        sort(remain1.begin(), remain1.end());
        sort(remain2.begin(), remain2.end());

        int result = 0;

        int remainder = sum % 3; // 1 or 2
        if(remainder == 1) {
            int remove1 = remain1.size() >= 1 ? remain1[0] : INT_MAX;            
            int remove2 = remain2.size() >= 2 ? remain2[0] + remain2[1] : INT_MAX;

            result = max(result, sum - min(remove1, remove2));              
        }
        else {
            int remove1 = remain2.size() >= 1 ? remain2[0] : INT_MAX;            
            int remove2 = remain1.size() >= 2 ? remain1[0] + remain1[1] : INT_MAX;

            result = max(result, sum - min(remove1, remove2));              
        }

        return result;
    }
};

// TC : O(nlogn)
// SC : O(n)


// Approach 2 : Recursion + Memoization

class Solution {
public:
    int solve(int i, int remain, vector<int>& nums, vector<vector<int>>& dp) {
        if(i >= nums.size()) {
            if(remain == 0) {
                return 0;
            }

            return INT_MIN;
        }

        if(dp[i][remain] != -1) {
            return dp[i][remain];
        }

        int take = nums[i] + solve(i + 1, (remain + nums[i]) % 3, nums, dp);
        int no_take = solve(i + 1, remain, nums, dp);

        return dp[i][remain] = max(take, no_take);
    }

    int maxSumDivThree(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(3, -1));
        
        return solve(0, 0, nums, dp);      
    }
};

// TC : O(n * 3)
// SC : O(n * 3)


// Approach 2 : Bottom Up

class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n + 1, vector<int>(3, INT_MIN));
        dp[n][0] = 0;

        for(int i = n - 1; i >= 0; i--) {
            for(int remain = 0; remain <= 2; remain++) {

                int newRemain = (remain + nums[i]) % 3;

                int take = (dp[i + 1][newRemain] == INT_MIN) ? INT_MIN : nums[i] + dp[i + 1][newRemain];

                int no_take = dp[i + 1][remain];

                dp[i][remain] = max(take, no_take);
            }
        }
        
        return dp[0][0];      
    }
};

// TC : O(n * 3)
// SC : O(n * 3)
