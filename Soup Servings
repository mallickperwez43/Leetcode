// Recursion -> TLE

class Solution {
public:
    
    vector<pair<int, int>> serves = {{100, 0}, {75, 25}, {50, 50}, {25, 75}};

    double solve(double A, double B) {

        if(A <= 0 && B <= 0)
            return 0.5; // returning half the probablity
        
        if(A <= 0)
            return 1.0; // A is empty now
        
        if(B <= 0)
            return 0.0; // we arent concerned with B to be empty
        
        double prob = 0.0;

        for(auto& p : serves) {
            
            int A_taken = p.first;
            int B_taken = p.second;

            prob += solve(A - A_taken, B - B_taken);
        }

        return 0.25 * prob;
    }

    double soupServings(int n) {
        return solve(n, n);
    }
};

// Recursion + Memoization -> MLE n is 10^9

class Solution {
public:
    
    vector<pair<int, int>> serves = {{100, 0}, {75, 25}, {50, 50}, {25, 75}};

    double solve(double A, double B, vector<vector<double>>& dp) {

        if(A <= 0 && B <= 0)
            return 0.5; // returning half the probablity
        
        if(A <= 0)
            return 1.0; // A is empty now
        
        if(B <= 0)
            return 0.0; // we arent concerned with B to be empty
        
        if(dp[A][B] != -1.0)
            return dp[A][B];

        double prob = 0.0;

        for(auto& p : serves) {
            
            int A_taken = p.first;
            int B_taken = p.second;

            prob += solve(A - A_taken, B - B_taken, dp);
        }

        return dp[A][B] = 0.25 * prob;
    }

    double soupServings(int n) {
        
        vector<vector<double>> dp(n + 1, vector<double>(n + 1, -1.0));

        return solve(n, n, dp);
    }
};


// Recursion + Memoization -> MLE n is 10^9 -> So setting a limiter

class Solution {
public:
    
    vector<pair<int, int>> serves = {{100, 0}, {75, 25}, {50, 50}, {25, 75}};

    double solve(double A, double B, vector<vector<double>>& dp) {

        if(A <= 0 && B <= 0)
            return 0.5; // returning half the probablity
        
        if(A <= 0)
            return 1.0; // A is empty now
        
        if(B <= 0)
            return 0.0; // we arent concerned with B to be empty
        
        if(dp[A][B] != -1.0)
            return dp[A][B];

        double prob = 0.0;

        for(auto& p : serves) {
            
            int A_taken = p.first;
            int B_taken = p.second;

            prob += solve(A - A_taken, B - B_taken, dp);
        }

        return dp[A][B] = 0.25 * prob;
    }

    double soupServings(int n) {

        // tricky
        if(n >= 5000)
            return 1.0;
        
        vector<vector<double>> dp(n + 1, vector<double>(n + 1, -1.0));

        return solve(n, n, dp);
    }
};
