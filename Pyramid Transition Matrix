class Solution {
public:
    bool solve(string curr, int idx, unordered_map<string, vector<char>>& mp, string above, unordered_map<string, bool>& dp) {
        if(curr.length() == 1) { // pyramid is formed and we are at the top
            return true;
        }
        
        string key = curr + "_" + to_string(idx) + "_" + above;

        if(dp.count(key)) {
            return dp[key];
        }

        if(idx == curr.length() - 1) { // time to move to above row
            return dp[key] = solve(above, 0, mp, "", dp);
        }

        string pair = curr.substr(idx, 2);
        if(mp.find(pair) == mp.end()) {
            return dp[key] = false;
        }

        for(char& ch : mp[pair]) {
            above.push_back(ch); // Do

            if(solve(curr, idx + 1, mp, above, dp) == true) { // Explore
                return dp[key] = true;
            }

            above.pop_back(); // Undo
        }

        return dp[key] = false;
    }

    bool pyramidTransition(string bottom, vector<string>& allowed) {
        unordered_map<string, vector<char>> mp;

        for(auto& pattern: allowed) {
            mp[pattern.substr(0,2)].push_back(pattern[2]);
        }
        
        // 3 changing parameter
        // curr, idx, above
        // map -> dp
        // string -> bool
        // curr_idx_above -> T/F
        unordered_map<string, bool> dp;

        return solve(bottom, 0, mp, "", dp);
    }
};
